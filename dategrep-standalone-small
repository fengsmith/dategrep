#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/dategrep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP';
  use strict;use warnings;package App::dategrep;use App::dategrep::Date qw(intervall_to_epoch date_to_epoch minutes_ago);use App::dategrep::Iterator::File;use App::dategrep::Iterator::Stdin;use App::dategrep::Iterator::Uncompress;use Config::Tiny;use Pod::Usage;use Getopt::Long;use Fcntl ":seek";use File::Basename qw(basename);use base 'Exporter';our@EXPORT_OK=qw(run);our$VERSION='0.54';our$app;BEGIN {$app=basename($0)}sub error {my ($msg,$rc)=@_;$rc=defined$rc ? $rc : 1;chomp($msg);warn "$app: $msg\n";return$rc}sub run {my%options;if ($ENV{DATEGREP_DEFAULT_FORMAT}){$options{format}=$ENV{DATEGREP_DEFAULT_FORMAT}}my$rc=GetOptions(\%options,'start|from=s','end|to=s','format=s','last-minutes=i','multiline!','blocksize=i','help|?','sort-files','man','configfile=s','interleave','byte-offsets','debug=s','version!',);if (!$rc){pod2usage(-exitstatus=>"NOEXIT",-verbose=>0);return 2}if ($options{version}){print "$VERSION\n";return 0}if ($options{help}){pod2usage(-verbose=>1,-exitstatus=>'NOEXIT');return 0}if ($options{man}){pod2usage(-exitstatus=>"NOEXIT",-verbose=>2);return 0}my$config=loadconfig($options{configfile});my%named_formats=('iso8601'=>"%O%Z",'rsyslog'=>"%b %e %H:%M:%S",'apache'=>"%d/%b/%Y:%T %z",);if (exists$config->{formats}){%named_formats=(%named_formats,%{$config->{formats}})}if (not defined$options{'format'}){return error("--format is a required parameter")}if (exists$named_formats{$options{'format'}}){$options{'format'}=$named_formats{$options{'format'}}}my ($start,$end)=(0,time());if (defined$options{'start'}){($start)=intervall_to_epoch($options{'start'},$options{'format'});return error("Illegal start time.")if not defined$start}if (defined$options{'end'}){($end)=intervall_to_epoch($options{'end'},$options{'format'});return error("Illegal end time.")if not defined$end}if (defined$options{'last-minutes'}){($start,$end)=minutes_ago($options{'last-minutes'})}if ($end < $start){($start,$end)=($end,$start)}if (defined$options{'debug'}&& $options{'debug'}eq 'time'){print "Start: $start End: $end\n";return 0}if (!@ARGV){push@ARGV,'-'}eval {if ($options{'byte-offsets'}){if (@ARGV==1 and -f $ARGV[0]){my$iter=App::dategrep::Iterator::File->new(filename=>$ARGV[0],start=>$start,end=>$end,multiline=>$options{multiline},format=>$options{format},);my ($fh,$byte_beg,$byte_end)=$iter->byte_offsets();if (not defined$byte_end){$byte_end=(stat($fh))[7]}print "$byte_beg $byte_end\n";return 0}}my@iterators=map {get_iterator($_,$start,$end,%options)}@ARGV;if ($options{'interleave'}){interleave_iterators($options{'format'},@iterators);return 0}if ($options{'sort-files'}){@iterators=sort_iterators($options{'format'},@iterators)}for my$iter (@iterators){if ($iter){while (my$entry=$iter->get_entry){print$entry}}}};return error($@)if $@;return 0}sub guess_format {my ($formats,@iterators)=@_;for my$iterator (@iterators){my$line=$iterator->peek;for my$format (@$formats){my$epoch=date_to_epoch($line,$format);if (defined$epoch){return$format}}}return}sub interleave_iterators {my ($format,@iterators)=@_;while (@iterators=sort_iterators($format,@iterators)){print$iterators[0]->get_entry}return}sub get_iterator {my ($filename,$start,$end,%options)=@_;my ($multiline,$format)=@options{qw(multiline format)};my@args=(start=>$start,end=>$end,multiline=>$multiline,format=>$format);my$iter;if ($filename eq '-'){$iter=App::dategrep::Iterator::Stdin->new(@args)}elsif ($filename =~ /\.(bz|bz2|gz|z)$/){$iter=App::dategrep::Iterator::Uncompress->new(@args,filename=>$filename)}else {$iter=App::dategrep::Iterator::File->new(@args,filename=>$filename)}return$iter}sub sort_iterators {my ($format,@iterators)=@_;my@timestamps;for my$iterator (@iterators){my$line=$iterator->peek;next if not defined$line;my ($epoch,$error)=date_to_epoch($line,$format);if (!$epoch){die "No date found in first line: $error\n"}push@timestamps,[$epoch,$iterator ]}return map {$_->[1]}sort {$a->[0]<=> $b->[0]}@timestamps}sub loadconfig {my$configfile=shift;if (not $configfile and $ENV{HOME}){$configfile="$ENV{HOME}/.dategreprc"}if (not defined$configfile or not -e $configfile){return}my$config=Config::Tiny->read($configfile);if (not defined$config){die "Error while parsing configfile: " .Config::Tiny->errstr()."\n"}return$config}1;
APP_DATEGREP

$fatpacked{"App/dategrep/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_DATE';
  package App::dategrep::Date;use strict;use warnings;use parent 'Exporter';use Date::Manip::Delta;use Date::Manip::Date;our@EXPORT_OK=qw(intervall_to_epoch date_to_epoch minutes_ago);sub intervall_to_epoch {my ($time,$format)=@_;if ($time =~ /^(.*) from (.*)$/){my ($delta,$date)=(Date::Manip::Delta->new($1),Date::Manip::Date->new($2));if ($delta->is_delta()){return$date->calc($delta)->secs_since_1970_GMT()}}return date_to_epoch($time,$format)}sub minutes_ago {my$minutes=shift;my$now=Date::Manip::Date->new("now");$now->set('s',0);my$ago=Date::Manip::Date->new("$minutes minutes ago");$ago->set('s',0);return ($ago->secs_since_1970_GMT(),$now->secs_since_1970_GMT())}{my$date;sub date_to_epoch {my ($str,$format)=@_;if (!$date){$date=Date::Manip::Date->new()}my$error;if ($format){$error=$date->parse_format($format,$str)}if (!$format or $error){$error=$date->parse($str)}return (undef,$date->err)if$error;return ($date->secs_since_1970_GMT())}}1;
APP_DATEGREP_DATE

$fatpacked{"App/dategrep/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_ITERATOR';
  package App::dategrep::Iterator;use strict;use warnings;use Moo;use App::dategrep::Date qw(date_to_epoch);has 'multiline'=>(is=>'ro',default=>sub {0});has 'start'=>(is=>'rw',required=>1);has 'end'=>(is=>'rw',required=>1);has 'format'=>(is=>'rw',required=>1);has 'fh'=>(is=>'lazy');has 'buffer'=>(is=>'rw',clearer=>1,);sub peek {my$self=shift;if (not defined$self->buffer){$self->buffer($self->fh->getline)}return$self->buffer}sub next_line_has_date {my$self=shift;my ($epoch)=date_to_epoch($self->peek,$self->format);return defined$epoch}sub getline {my$self=shift;my$buffer=$self->buffer();if (defined$buffer){$self->clear_buffer();return$buffer}return$self->fh->getline};1;
APP_DATEGREP_ITERATOR

$fatpacked{"App/dategrep/Iterator/Fh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_ITERATOR_FH';
  package App::dategrep::Iterator::Fh;use strict;use warnings;use App::dategrep::Date 'date_to_epoch';use Moo;use FileHandle;extends 'App::dategrep::Iterator';has fh=>(is=>'ro',required=>1);has eof=>(is=>'rw',default=>sub {0});sub get_entry {my$self=shift;return if$self->eof();LINE: while (my$line=$self->getline){my ($epoch,$error)=date_to_epoch($line,$self->format);if (!$epoch){if ($self->multiline){return$line}die "Unparsable line: $line\n"}if ($epoch >= $self->end){$self->eof(1);return}if ($epoch >= $self->start){return$line}}return}1;
APP_DATEGREP_ITERATOR_FH

$fatpacked{"App/dategrep/Iterator/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_ITERATOR_FILE';
  package App::dategrep::Iterator::File;use strict;use warnings;use Fcntl ":seek";use Moo;use FileHandle;use App::dategrep::Date qw(date_to_epoch);extends 'App::dategrep::Iterator';has 'filename'=>(is=>'ro',required=>1);has 'blocksize'=>(is=>'lazy');has 'tell_beg'=>(is=>'rw');has 'tell_end'=>(is=>'rw');sub _build_blocksize {my$self=shift;return (stat($self->filename))[11]|| 8192}sub _build_fh {my$self=shift;my ($fh,$tell_beg,$tell_end)=$self->byte_offsets();$self->tell_beg($tell_beg);$self->tell_end($tell_end);if (defined($tell_beg)){$fh->seek($tell_beg,SEEK_SET)}return$fh}sub get_entry {my$self=shift;my$line=$self->getline();return if defined($self->tell_end)&& ($self->fh->tell > $self->tell_end);if ($self->multiline &&!$self->fh->eof &&!$self->next_line_has_date){$line .= $self->getline()}return$line}sub byte_offsets {my$self=shift;my$filename=$self->filename;open(my$fh,'<',$filename)or die "Can't open $filename: $!\n";my$test_line=$fh->getline;if (defined($test_line)){my ($epoch,$error)=date_to_epoch($test_line,$self->format);if ($error){die "No date found in first line: $error\n"}$fh->seek(0,SEEK_SET);my$tell_beg=$self->search($fh,$self->start,format=>$self->format,);if (defined$tell_beg){my$tell_end=$self->search($fh,$self->end,min_byte=>$tell_beg,format=>$self->format);return$fh,$tell_beg,$tell_end}}return$fh,0,-1}sub search {my$self=shift;my ($fh,$key,%options)=@_;my@stat=$fh->stat or return;my$size=$stat[7];my$blksize=$self->blocksize;my$min_byte=$options{min_byte};my$multiline=$self->multiline;my ($min,$max,$mid)=(0,int($size / $blksize));if (defined$min_byte){$min=int($min_byte / $blksize)}BLOCK: while ($max - $min > 1){$mid=int(($max + $min)/ 2);$fh->seek($mid * $blksize,0)or return;$fh->getline if$mid;LINE: while (my$line=$fh->getline()){my ($epoch)=date_to_epoch($line,$self->format);if (!$epoch){next LINE if$multiline;chomp($line);die "Unparsable line: $line\n"}if ($multiline){my$byte=$fh->tell;$mid=int($byte / $blksize)}$epoch < $key ? $min=$mid : $max=$mid;next BLOCK}}$min *= $blksize;$fh->seek($min,0)or return;$fh->getline if$min;for (;;){$min=$fh->tell;defined(my$line=$fh->getline)or last;my ($epoch)=date_to_epoch($line,$self->format);if (!$epoch){next if$multiline;chomp($line);die "Unparsable line: $line\n"}if ($epoch >= $key){$fh->seek($min,0);return$min}}return}1;
APP_DATEGREP_ITERATOR_FILE

$fatpacked{"App/dategrep/Iterator/Stdin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_ITERATOR_STDIN';
  package App::dategrep::Iterator::Stdin;use strict;use warnings;use Moo;extends 'App::dategrep::Iterator::Fh';sub BUILDARGS {my ($class,@args)=@_;@args=ref$args[0]? @{$args[0]}: @args;return {@args,fh=>\*STDIN }}1;
APP_DATEGREP_ITERATOR_STDIN

$fatpacked{"App/dategrep/Iterator/Uncompress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_DATEGREP_ITERATOR_UNCOMPRESS';
  package App::dategrep::Iterator::Uncompress;use strict;use warnings;use Moo;extends 'App::dategrep::Iterator::Fh';has filename=>(is=>'ro',required=>1);has fh=>(is=>'lazy');sub _build_fh {my$self=shift;my@uncompress;if ($self->filename =~ /\.(bz|bz2)$/){@uncompress=qw(bzcat)}elsif ($self->filename =~ /\.(gz|z)$/){@uncompress=qw(gzip -c -d)}else {die "unknown ending for compressed file " .$self->filename ."\n"}open(my$pipe,'-|',@uncompress,$self->filename)or die "Can't open @uncompress: $!\n";return$pipe}1;
APP_DATEGREP_ITERATOR_UNCOMPRESS

$fatpacked{"Config/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONFIG_TINY';
  package Config::Tiny;use strict;our$VERSION='2.20';BEGIN {require 5.008001;$Config::Tiny::errstr=''}sub new {bless {},shift}sub read {my$class=ref $_[0]? ref shift : shift;my$file=shift or return$class->_error('No file name provided');my$encoding=shift;$encoding=$encoding ? "<:$encoding" : '<';local $/=undef;open(CFG,$encoding,$file)or return$class->_error("Failed to open file '$file' for reading: $!");my$contents=<CFG>;close(CFG);return$class -> _error("Reading from '$file' returned undef")if (!defined$contents);return$class->read_string($contents)}sub read_string {my$class=ref $_[0]? ref shift : shift;my$self=bless {},$class;return undef unless defined $_[0];my$ns='_';my$counter=0;for (split /(?:\015{1,2}\012|\015|\012)/,shift){$counter++;next if /^\s*(?:\#|\;|$)/;s/\s\;\s.+$//g;if (/^\s*\[\s*(.+?)\s*\]\s*$/){$self->{$ns=$1}||={};next}if (/^\s*([^=]+?)\s*=\s*(.*?)\s*$/){$self->{$ns}->{$1}=$2;next}return$self->_error("Syntax error at line $counter: '$_'")}$self}sub write {my$self=shift;my$file=shift or return$self->_error('No file name provided');my$encoding=shift;$encoding=$encoding ? ">:$encoding" : '>';my$string=$self->write_string;return undef unless defined$string;open(CFG,$encoding,$file)or return$self->_error("Failed to open file '$file' for writing: $!");print CFG$string;close CFG;return 1}sub write_string {my$self=shift;my$contents='';for my$section (sort {(($b eq '_')<=> ($a eq '_'))|| ($a cmp $b)}keys %$self){return$self->_error("Illegal whitespace in section name '$section'")if$section =~ /(?:^\s|\n|\s$)/s;my$block=$self->{$section};$contents .= "\n" if length$contents;$contents .= "[$section]\n" unless$section eq '_';for my$property (sort keys %$block){return$self->_error("Illegal newlines in property '$section.$property'")if$block->{$property}=~ /(?:\012|\015)/s;$contents .= "$property=$block->{$property}\n"}}$contents}sub errstr {$Config::Tiny::errstr}sub _error {$Config::Tiny::errstr=$_[1];undef}1;
CONFIG_TINY

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;use strict;use warnings;our$VERSION='0.12';use Sub::Exporter::Progressive -setup=>{exports=>[qw(in_global_destruction) ],groups=>{default=>[-all ]},};if (defined ${^GLOBAL_PHASE}){eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1' or die $@}elsif (eval {require Devel::GlobalDestruction::XS;no warnings 'once';*in_global_destruction=\&Devel::GlobalDestruction::XS::in_global_destruction;1}){}else {require B;eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1' or die $@}1;
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use Moo::_strictures;use Moo::_Utils;use Moo::Object ();our@ISA=qw(Moo::Object);use Sub::Quote qw(quote_sub quoted_from_sub quotify);use Scalar::Util 'blessed';use overload ();use Module::Runtime qw(use_module);BEGIN {our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')});our$CAN_HAZ_XS_PRED=$CAN_HAZ_XS && (eval {Class::XSAccessor->VERSION('1.17')})}my$module_name_only=qr/\A$Module::Runtime::module_name_rx\z/;sub _die_overwrite {my ($pkg,$method,$type)=@_;die "You cannot overwrite a locally defined method ($method) with " .($type || 'an accessor')}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$spec->{allow_overwrite}++ if$name =~ s/^\+//;die "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||='_build_'.$name unless exists$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){die "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;die "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ $module_name_only}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}if (($spec->{coerce}||0)eq 1){my$isa=$spec->{isa};if (blessed$isa and $isa->can('coercion')){$spec->{coerce}=$isa->coercion}elsif (blessed$isa and $isa->can('coerce')){$spec->{coerce}=sub {$isa->coerce(@_)}}else {die "Invalid coercion for $into->$name - no appropriate type constraint"}}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${reader}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}}}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${accessor}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}}}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${writer}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}}}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${pred}")}{CODE};if (our$CAN_HAZ_XS && our$CAN_HAZ_XS_PRED){$methods{$pred}=$self->_generate_xs(exists_predicates=>$into,$pred,$name,$spec)}else {$methods{$pred}=quote_sub "${into}::${pred}"=>'    '.$self->_generate_simple_has('$_[0]',$name,$spec)."\n" }}if (my$pred=$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$spec->{builder_sub})}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${cl}")}{CODE};$methods{$cl}=quote_sub "${into}::${cl}"=>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||='_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){map [$_=>$_ ],use_module('Moo::Role')->methods_provided_by(use_module($hspec))}else {die "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${proxy}")}{CODE};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}"=>$self->_generate_delegation($asserter,$target,\@args),delete$self->{captures}}}if (my$asserter=$spec->{asserter}){$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}"=>$self->_generate_asserter($name,$spec),delete$self->{captures}}\%methods}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\quotify $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\quotify $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): quotify$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_simple_get(@args);($code,delete$self->{captures})}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=quotify$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;if ($self->is_simple_set($name,$spec)){$self->_generate_simple_set('$_[0]',$name,$spec,'$_[1]')}else {my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};my$value_store='$_[0]';my$code;if ($coerce){$value_store='$value';$code="do { my (\$self, \$value) = \@_;\n" ."        \$value = " .$self->_generate_coerce($name,$value_store,$coerce).";\n"}else {$code="do { my \$self = shift;\n"}if ($isa_check){$code .= "        ".$self->_generate_isa_check($name,$value_store,$isa_check).";\n"}my$simple=$self->_generate_simple_set('$self',$name,$spec,$value_store);if ($trigger){my$fire=$self->_generate_trigger($name,'$self',$value_store,$trigger);$code .= "        ".$simple.";\n        ".$fire.";\n" ."        $value_store;\n"}else {$code .= "        ".$simple.";\n"}$code .= "      }";$code}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return quotify($name)if!defined($init_arg)or $init_arg eq $name;return quotify($name).' (constructor argument: '.quotify($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_wrap_attr_exception($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce),1,)}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _wrap_attr_exception {my ($self,$name,$step,$arg,$code,$want_return)=@_;my$prefix=quotify("${step} for "._attr_desc($name,$arg).' failed: ');"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n" .'    init_arg => '.quotify($arg).",\n" .'    name     => '.quotify($name).",\n" .'    step     => '.quotify($step).",\n" ."  };\n" .($want_return ? '  my $_return;'."\n" : '').'  my $_error;'."\n" ."  {\n" .'    my $_old_error = $@;'."\n" ."    if (!eval {\n" .'      $@ = $_old_error;'."\n" .($want_return ? '      $_return ='."\n" : '').'      '.$code.";\n" ."      1;\n" ."    }) {\n" .'      $_error = $@;'."\n" .'      if (!ref $_error) {'."\n" .'        $_error = '.$prefix.'.$_error;'."\n" ."      }\n" ."    }\n" .'    $@ = $_old_error;'."\n" ."  }\n" .'  die $_error if $_error;'."\n" .($want_return ? '  $_return;'."\n" : '')."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_wrap_attr_exception($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_}.$self->_sanitize_name($name);$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_}.$self->_sanitize_name($name);$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub _sanitize_name {my ($self,$name)=@_;$name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;$name}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;if ($self->has_eager_default($name,$spec)){my$get_indent=' ' x ($spec->{isa}? 6 : 4);my$get_default=$self->_generate_get_default('$new',$name,$spec);my$get_value=defined($spec->{init_arg})? "(\n${get_indent}  ${test}\n" ."${get_indent}   ? ${source}\n${get_indent}   : " .$get_default ."\n${get_indent})" : $get_default;if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce},$init_arg)}($spec->{isa}? "    {\n      my \$value = ".$get_value.";\n      " .$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg).";\n" .'      '.$self->_generate_simple_set($me,$name,$spec,'$value').";\n" ."    }\n" : '    '.$self->_generate_simple_set($me,$name,$spec,$get_value).";\n").($spec->{trigger}? '    ' .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger})." if ${test};\n" : '')}else {"    if (${test}) {\n" .($spec->{coerce}? "      $source = " .$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg).";\n" : "").($spec->{isa}? "      " .$self->_generate_isa_check($name,$source,$spec->{isa},$init_arg).";\n" : "")."      ".$self->_generate_simple_set($me,$name,$spec,$source).";\n" .($spec->{trigger}? "      " .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}).";\n" : "")."    }\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=quotify$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple="do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";Moo::_Utils::lt_5_8_3()? <<"EOC" : $weak_simple}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  unless (".$self->_generate_simple_has('$_[0]',$name,$spec).") {\n" .qq!    die "Attempted to access '${name}' but it is not set";\n! ."  }\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$invalid="Invalid $setting '" .overload::StrVal($value)."' for $into not a coderef";$invalid .= " $appended" if$appended;unless (ref$value and (ref$value eq 'CODE' or blessed($value))){die "$invalid or code-convertible object"}unless (eval {\&$value}){die "$invalid and could not be converted to a coderef: $@"}1}1;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use Moo::_strictures;use Sub::Quote qw(quote_sub unquote_sub quotify);use Sub::Defer;use Moo::_Utils qw(_getstash _getglob);use Moo;sub register_attribute_specs {my ($self,@new_specs)=@_;$self->assert_constructor;my$specs=$self->{attribute_specs}||={};while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){die "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};for my$key (keys %$old_spec){if (!exists$new_spec->{$key}){$new_spec->{$key}=$old_spec->{$key}unless$key eq 'handles'}elsif ($key eq 'moosify'){$new_spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}($old_spec->{$key},$new_spec->{$key})]}}}if ($new_spec->{required}&&!(exists$new_spec->{default}|| $new_spec->{builder}||!exists$new_spec->{init_arg}|| defined$new_spec->{init_arg})){die "You cannot have a required attribute (${name})" ." without a default, builder, or an init_arg"}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||=$self->_build_construction_string}sub buildall_generator {require Method::Generate::BuildAll;Method::Generate::BuildAll->new}sub _build_construction_string {my ($self)=@_;my$builder=$self->{construction_builder};$builder ? $self->$builder : 'bless(' .$self->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;$self->assert_constructor;my$package=$self->{package};my (undef,@isa)=@{mro::get_linear_isa($package)};my$isa=join ',',@isa;$self->{deferred_constructor}=defer_sub "${package}::new"=>sub {my (undef,@new_isa)=@{mro::get_linear_isa($package)};if (join(',',@new_isa)ne $isa){my ($expected_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa;my ($found_new)=grep {*{_getglob($_.'::new')}{CODE}}@new_isa;if (($found_new||'')ne ($expected_new||'')){$found_new ||='none';$expected_new ||='none';die "Expected parent constructor of $package expected to be" ." $expected_new, but found $found_new: changing the inheritance" ." chain (\@ISA) at runtime is unsupported"}}unquote_sub$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1 })};$self}sub current_constructor {my ($self,$package)=@_;return *{_getglob("${package}::new")}{CODE}}sub assert_constructor {my ($self)=@_;my$package=$self->{package}or return 1;my$current=$self->current_constructor($package)or return 1;my$deferred=$self->{deferred_constructor}or die "Unknown constructor for $package already exists";return 1 if$deferred==$current;my$current_deferred=(Sub::Defer::defer_info($current)||[])->[3];if ($current_deferred && $current_deferred==$deferred){die "Constructor for $package has been inlined and cannot be updated"}die "Constructor for $package has been replaced with an unknown sub"}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$body='    my $class = shift;'."\n" .'    $class = ref($class) if ref($class);'."\n";$body .= $self->_handle_subconstructor($into,$name);my$into_buildargs=$into->can('BUILDARGS');if ($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS){$body .= $self->_generate_args_via_buildargs}else {$body .= $self->_generate_args}$body .= $self->_check_required($spec);$body .= '    my $new = '.$self->construction_string.";\n";$body .= $self->_assign_new($spec);if ($into->can('BUILD')){$body .= $self->buildall_generator->buildall_body_for($into,'$new','$args')}$body .= '    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.quotify($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg_key=quotify($test{$_});my$test="exists \$args->{$arg_key}";my$source="\$args->{$arg_key}";my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$test{$_},))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my%s=%{$spec->{$_}};$s{required}and not($s{builder}or $s{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, qw(' .join(' ',@required_init).')) {'."\n" .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n" ."    }\n"}sub new {my$class=shift;delete _getstash(__PACKAGE__)->{new};bless$class->BUILDARGS(@_),$class}Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },construction_builder=>{is=>'bare' },subconstructor_handler=>{is=>'ro' },package=>{is=>'bare' },);1;
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  package Module::Runtime;BEGIN {require 5.006}BEGIN {${^WARNING_BITS}=""}our$VERSION="0.014";our@EXPORT_OK=qw($module_name_rx is_module_name is_valid_module_name check_module_name module_notional_filename require_module use_module use_package_optimistically $top_module_spec_rx $sub_module_spec_rx is_module_spec is_valid_module_spec check_module_spec compose_module_name);my%export_ok=map {($_=>undef)}@EXPORT_OK;sub import {my$me=shift;my$callpkg=caller(0);my$errs="";for(@_){if(exists$export_ok{$_}){if(/\A\$(.*)\z/s){*{$callpkg."::".$1}=\$$1}else {*{$callpkg."::".$_}=\&$_}}else {$errs .= "\"$_\" is not exported by the $me module\n"}}if($errs ne ""){die "${errs}Can't continue after import errors "."at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n"}}sub _is_string($) {my($arg)=@_;return defined($arg)&& ref(\$arg)eq "SCALAR"}our$module_name_rx=qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;my$qual_module_spec_rx=qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;my$unqual_top_module_spec_rx=qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$top_module_spec_rx=qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;my$unqual_sub_module_spec_rx=qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;our$sub_module_spec_rx=qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;sub is_module_name($) {_is_string($_[0])&& $_[0]=~ /\A$module_name_rx\z/o}*is_valid_module_name=\&is_module_name;sub check_module_name($) {unless(&is_module_name){die +(_is_string($_[0])? "`$_[0]'" : "argument")." is not a module name\n"}}sub module_notional_filename($) {&check_module_name;my($name)=@_;$name =~ s!::!/!g;return$name.".pm"}BEGIN {*_WORK_AROUND_HINT_LEAKAGE="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE="$]" < 5.009 ? sub(){1}: sub(){0}}BEGIN {if(_WORK_AROUND_BROKEN_MODULE_STATE){eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  };die $@ if $@ ne ""}}sub require_module($) {local %^H if _WORK_AROUND_HINT_LEAKAGE;if(_WORK_AROUND_BROKEN_MODULE_STATE){my$notional_filename=&module_notional_filename;my$guard=bless([$notional_filename ],"Module::Runtime::__GUARD__");my$result=CORE::require($notional_filename);pop @$guard;return$result}else {return scalar(CORE::require(&module_notional_filename))}}sub use_module($;$) {my($name,$version)=@_;require_module($name);$name->VERSION($version)if @_ >= 2;return$name}sub use_package_optimistically($;$) {my($name,$version)=@_;my$fn=module_notional_filename($name);eval {local$SIG{__DIE__};require_module($name)};die $@ if $@ ne "" && ($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s || $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);$name->VERSION($version)if @_ >= 2;return$name}sub is_module_spec($$) {my($prefix,$spec)=@_;return _is_string($spec)&& $spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o : qr/\A$top_module_spec_rx\z/o)}*is_valid_module_spec=\&is_module_spec;sub check_module_spec($$) {unless(&is_module_spec){die +(_is_string($_[1])? "`$_[1]'" : "argument")." is not a module specification\n"}}sub compose_module_name($$) {my($prefix,$spec)=@_;check_module_name($prefix)if defined$prefix;&check_module_spec;if($spec =~ s#\A(?:/|::)##){}else {$spec=$prefix."::".$spec if defined$prefix}$spec =~ s#/#::#g;return$spec}1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use Moo::_strictures;use Moo::_Utils;our$VERSION='2.000001';$VERSION=eval$VERSION;require Moo::sification;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;_set_loaded(caller);strict->import;warnings->import;if ($INC{'Role/Tiny.pm'}and Role::Tiny->is_role($target)){die "Cannot import Moo into a role"}$MAKERS{$target}||={};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};my$stash=_getstash($target);my@not_methods=map {*$_{CODE}||()}grep!ref($_),values %$stash;@{$MAKERS{$target}{not_methods}={}}{@not_methods}=@not_methods;$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{'Role/Tiny.pm'}&& Role::Tiny->is_role($superclass)){require Carp;Carp::croak("Can't extend role '$superclass'")}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){$old->assert_constructor;delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}no warnings 'once';$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||=do {my$maker_class=do {if (my$m=do {require Sub::Defer;if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||=do {require Method::Generate::Constructor;require Sub::Defer;my%construct_opts=(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n" .'          return $class->'.$target.'::SUPER::new(@_);'."\n" .'        }'."\n" .'        '.$class.'->_constructor_maker_for($class);'."\n" .'        return $class->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object('."\n" .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n" .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n" .'        );'."\n" .'      }'."\n"),);my$con;my@isa=@{mro::get_linear_isa($target)};shift@isa;if (my ($parent_new)=grep {*{_getglob($_.'::new')}{CODE}}@isa){if ($parent_new eq 'Moo::Object'){}elsif (my$makers=$MAKERS{$parent_new}){$con=$makers->{constructor};$construct_opts{construction_string}=$con->construction_string if$con}elsif ($parent_new->can('BUILDALL')){$construct_opts{construction_builder}=sub {my$inv=$target->can('BUILDARGS')? '' : 'Moo::Object::';'do {' .'  my $args = $class->'.$inv.'BUILDARGS(@_);' .'  $args->{__no_BUILD__} = 1;' .'  $class->'.$target.'::SUPER::new($args);' .'}'}}else {$construct_opts{construction_builder}=sub {'$class->'.$target.'::SUPER::new(' .($target->can('FOREIGNBUILDARGS')? '$class->FOREIGNBUILDARGS(@_)' : '@_').')'}}}($con ? ref($con): 'Method::Generate::Constructor')->new(%construct_opts)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}sub _concrete_methods_of {my ($me,$role)=@_;my$makers=$MAKERS{$role};my$stash=_getstash($role);my$not_methods={reverse %{$makers->{not_methods}||{}}};+{map {my$code=*{$stash->{$_}}{CODE};(!$code or exists$not_methods->{$code})? (): ($_=>$code)}grep!ref($stash->{$_}),keys %$stash }}1;
MOO

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;use Moo::_strictures;package Moo::HandleMoose;our%TYPE_MAP;package Moo::HandleMoose::_TypeMap;use Scalar::Util ();use Config;our%WEAK_TYPES;sub _str_to_ref {my$in=shift;return$in if ref$in;if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/){my$id=do {no warnings 'portable';hex "$1"};require B;my$sv=bless \$id,'B::SV';my$ref=eval {$sv->object_2svref};if (!defined$ref){die <<'END_ERROR'}return$ref}return$in}sub TIEHASH {bless {},$_[0]}sub STORE {my ($self,$key,$value)=@_;my$type=_str_to_ref($key);$WEAK_TYPES{$type}=$type;Scalar::Util::weaken($WEAK_TYPES{$type})if ref$type;$self->{$key}=$value}sub FETCH {$_[0]->{$_[1]}}sub FIRSTKEY {my$a=scalar keys %{$_[0]};each %{$_[0]}}sub NEXTKEY {each %{$_[0]}}sub EXISTS {exists $_[0]->{$_[1]}}sub DELETE {delete $_[0]->{$_[1]}}sub CLEAR {%{$_[0]}=()}sub SCALAR {scalar %{$_[0]}}sub CLONE {my@types=map {defined$WEAK_TYPES{$_}? ($WEAK_TYPES{$_}=>$TYPE_MAP{$_}): ()}keys%TYPE_MAP;%WEAK_TYPES=();%TYPE_MAP=@types}sub DESTROY {my%types=%{$_[0]};untie%TYPE_MAP;%TYPE_MAP=%types}if ($Config{useithreads}){my@types=%TYPE_MAP;tie%TYPE_MAP,__PACKAGE__;%TYPE_MAP=@types}1;
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use Moo::_strictures;our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}$NO_BUILD{$class}and return bless({},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({},$class): do {my$proto=ref($_[0])eq 'HASH' ? $_[0]: {@_};bless({},$class)->BUILDALL($proto)}}sub BUILDARGS {my$class=shift;if (scalar @_==1){unless (defined $_[0]&& ref $_[0]eq 'HASH'){die "Single parameters to new() must be a HASH ref" ." data => ".$_[0]."\n"}return {%{$_[0]}}}elsif (@_ % 2){die "The new() method for $class expects a hash reference or a" ." key/value list. You passed an odd number of arguments\n"}else {return {@_}}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||=do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {require Moo::Role;my$does=Moo::Role->can("does_role");{no warnings 'redefine';*does=$does}goto &$does}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;no warnings 'once';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use constant lt_5_8_3=>($] < 5.008003 or $ENV{MOO_TEST_PRE_583})? 1 : 0;use constant can_haz_subutil=>$INC{"Sub/Util.pm"}|| (!$INC{"Sub/Name.pm"}&& eval {require Sub::Util});use constant can_haz_subname=>$INC{"Sub/Name.pm"}|| (!$INC{"Sub/Util.pm"}&& eval {require Sub::Name});use Moo::_strictures;use Module::Runtime qw(use_package_optimistically module_notional_filename);use Devel::GlobalDestruction ();use Exporter qw(import);use Moo::_mro;use Config;our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _get_linear_isa _getstash _install_coderef _name_coderef _unimport_coderefs _in_global_destruction _set_loaded);sub _in_global_destruction ();*_in_global_destruction=\&Devel::GlobalDestruction::in_global_destruction;sub _install_modifier {my ($into,$type,$name,$code)=@_;if (my$to_modify=$into->can($name)){require Sub::Defer;Sub::Defer::undefer_sub($to_modify)}Class::Method::Modifiers::install_modifier(@_)}our%MAYBE_LOADED;sub _load_module {my$module=$_[0];my$file=module_notional_filename($module);use_package_optimistically($module);return 1 if$INC{$file};my$error=$@ || "Can't locate $file";my$stash=_getstash($module)||{};return 1 if grep +(!ref($_)and *$_{CODE}),values %$stash;return 1 if$INC{"Moose.pm"}&& Class::MOP::class_of($module)or Mouse::Util->can('find_meta')&& Mouse::Util::find_meta($module);die$error}sub _maybe_load_module {my$module=$_[0];return$MAYBE_LOADED{$module}if exists$MAYBE_LOADED{$module};if(!eval {use_package_optimistically($module)}){warn "$module exists but failed to load with error: $@"}elsif ($INC{module_notional_filename($module)}){return$MAYBE_LOADED{$module}=1}return$MAYBE_LOADED{$module}=0}sub _set_loaded {$INC{Module::Runtime::module_notional_filename($_[0])}||=$_[1]}sub _get_linear_isa {return mro::get_linear_isa($_[0])}sub _install_coderef {my ($glob,$code)=(_getglob($_[0]),_name_coderef(@_));no warnings 'redefine';if (*{$glob}{CODE}){*{$glob}=$code}else {no warnings 'prototype';*{$glob}=$code}}sub _name_coderef {shift if @_ > 2;can_haz_subutil ? Sub::Util::set_subname(@_): can_haz_subname ? Sub::Name::subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}if ($Config{useithreads}){require Moo::HandleMoose::_TypeMap}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;use Moo::_strictures;if ($] >= 5.010){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;use strict;use warnings;sub import {if ($ENV{MOO_FATAL_WARNINGS}){require strictures;strictures->VERSION(2);@_=('strictures');goto&strictures::import}else {strict->import;warnings->import}}1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use Moo::_strictures;no warnings 'once';use Devel::GlobalDestruction qw(in_global_destruction);sub unimport {our$disarmed=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disarmed or in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}1;
MOO_SIFICATION

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use Moo::_strictures;use Exporter qw(import);use Moo::_Utils qw(_getglob _install_coderef);use Scalar::Util qw(weaken);our$VERSION='2.000001';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub undefer_all);our@EXPORT_OK=qw(undefer_package);our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my ($target,$maker,$undeferred_ref)=@{$DEFERRED{$deferred}||return$deferred};return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}$DEFERRED{$made}=$DEFERRED{$deferred};weaken$DEFERRED{$made}unless$target;return$made}sub undefer_all {undefer_sub($_)for keys%DEFERRED;return}sub undefer_package {my$package=shift;my@subs=grep {$DEFERRED{$_}[0]=~ /^${package}::[^:]+$/}keys%DEFERRED;undefer_sub($_)for@subs;return}sub defer_info {my ($deferred)=@_;my$info=$DEFERRED{$deferred||''}or return undef;[@$info ]}sub defer_sub {my ($target,$maker)=@_;my$undeferred;my$deferred_info;my$deferred=sub {$undeferred ||=undefer_sub($deferred_info->[3]);goto &$undeferred};$deferred_info=[$target,$maker,\$undeferred,$deferred ];weaken($deferred_info->[3]);weaken($DEFERRED{$deferred}=$deferred_info);_install_coderef($target=>$deferred)if defined$target;return$deferred}sub CLONE {%DEFERRED=map {defined $_ && $_->[3]? ($_->[3]=>$_): ()}values%DEFERRED;for my$info (values%DEFERRED){weaken($info)unless$info->[0]&& ${$info->[2]}}}1;
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;use strict;use warnings;our$VERSION='0.001011';use Carp ();use List::Util ();sub import {my ($self,@args)=@_;my$inner_target=caller;my$export_data=sub_export_options($inner_target,@args);my$full_exporter;no strict 'refs';@{"${inner_target}::EXPORT_OK"}=@{$export_data->{exports}};@{"${inner_target}::EXPORT"}=@{$export_data->{defaults}};%{"${inner_target}::EXPORT_TAGS"}=%{$export_data->{tags}};*{"${inner_target}::import"}=sub {use strict;my ($self,@args)=@_;if (List::Util::first {ref ||!m/ \A [:-]? \w+ \z /xm}@args){Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed' unless eval {require Sub::Exporter};$full_exporter ||=Sub::Exporter::build_exporter($export_data->{original});goto$full_exporter}elsif (defined(my$num=List::Util::first {!ref and m/^\d/}@args)){die "cannot export symbols with a leading digit: '$num'"}else {require Exporter;s/ \A - /:/xm for@args;@_=($self,@args);goto \&Exporter::import}};return}my$too_complicated=<<'DEATH';sub sub_export_options {my ($inner_target,$setup,$options)=@_;my@exports;my@defaults;my%tags;if ($setup eq '-setup'){my%options=%$options;OPTIONS: for my$opt (keys%options){if ($opt eq 'exports'){Carp::croak$too_complicated if ref$options{exports}ne 'ARRAY';@exports=@{$options{exports}};Carp::croak$too_complicated if List::Util::first {ref}@exports}elsif ($opt eq 'groups'){%tags=%{$options{groups}};for my$tagset (values%tags){Carp::croak$too_complicated if List::Util::first {/ \A - (?! all \b ) /x || ref}@{$tagset}}@defaults=@{$tags{default}|| []}}else {Carp::croak$too_complicated}}@{$_}=map {/ \A  [:-] all \z /x ? @exports : $_}@{$_}for \@defaults,values%tags;$tags{all}||=[@exports ];my%exports=map {$_=>1}@exports;my@errors=grep {not $exports{$_}}@defaults;Carp::croak join(', ',@errors)." is not exported by the $inner_target module\n" if@errors}return {exports=>\@exports,defaults=>\@defaults,original=>$options,tags=>\%tags,}}1;
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_NAME';
  package Sub::Name;use 5.006;use strict;use warnings;our$VERSION='0.05';use base 'Exporter';use base 'DynaLoader';our@EXPORT=qw(subname);our@EXPORT_OK=@EXPORT;bootstrap Sub::Name$VERSION;1;
SUB_NAME

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;sub _clean_eval {eval $_[0]}use Moo::_strictures;use Sub::Defer qw(defer_sub);use Scalar::Util qw(weaken);use Exporter qw(import);use B ();BEGIN {*_HAVE_PERLSTRING=defined&B::perlstring ? sub(){1}: sub(){0}}our$VERSION='2.000001';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub qsub);our@EXPORT_OK=qw(quotify capture_unroll inlinify);our%QUOTED;sub quotify {!defined $_[0]? 'undef()' : _HAVE_PERLSTRING ? B::perlstring($_[0]): qq["\Q$_[0]\E"]}sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or die "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//){$do .= $1}if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms){my ($pre,$indent,$code_args)=($1,$2,$3);$do .= $pre;if ($code_args ne $args){$do .= $indent .'my ('.$code_args.') = ('.$args.'); '}}elsif ($local || $args ne '@_'){$do .= ($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$code.' }'}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=ref($_[-1])eq 'HASH' ? pop : undef;undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];my ($package,$hints,$bitmask,$hintshash)=(caller(0))[0,8,9,10];my$context ="# BEGIN quote_sub PRELUDE\n" ."package $package;\n" ."BEGIN {\n" ."  \$^H = ".quotify($hints).";\n" ."  \${^WARNING_BITS} = ".quotify($bitmask).";\n" ."  \%^H = (\n" .join('',map "    ".quotify($_)." => ".quotify($hintshash->{$_}).",",keys %$hintshash)."  );\n" ."}\n" ."# END quote_sub PRELUDE\n";$code="$context$code";my$quoted_info;my$unquoted;my$deferred=defer_sub +($options->{no_install}? undef : $name)=>sub {$unquoted if 0;unquote_sub($quoted_info->[4])};$quoted_info=[$name,$code,$captures,\$unquoted,$deferred ];weaken($quoted_info->[3]);weaken($quoted_info->[4]);weaken($QUOTED{$deferred}=$quoted_info);return$deferred}sub quoted_from_sub {my ($sub)=@_;my$quoted_info=$QUOTED{$sub||''}or return undef;my ($name,$code,$captured,$unquoted,$deferred)=@{$quoted_info};$unquoted &&=$$unquoted;if (($deferred && $deferred eq $sub)|| ($unquoted && $unquoted eq $sub)){return [$name,$code,$captured,$unquoted,$deferred ]}return undef}sub unquote_sub {my ($sub)=@_;my$quoted=$QUOTED{$sub}or return undef;my$unquoted=$quoted->[3];unless ($unquoted && $$unquoted){my ($name,$code,$captures)=@$quoted;my$make_sub="{\n";my%captures=$captures ? %$captures : ();$captures{'$_UNQUOTED'}=\$unquoted;$captures{'$_QUOTED'}=\$quoted;$make_sub .= capture_unroll("\$_[1]",\%captures,2);$make_sub .= ($name ? "  no warnings 'closure';\n  sub ${name} {\n" : "  \$\$_UNQUOTED = sub {\n");$make_sub .= "  \$_QUOTED if 0;\n";$make_sub .= "  \$_UNQUOTED if 0;\n";$make_sub .= $code;$make_sub .= "  }".($name ? '' : ';')."\n";if ($name){$make_sub .= "  \$\$_UNQUOTED = \\&${name}\n"}$make_sub .= "}\n1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{no strict 'refs';local *{$name}if$name;my ($success,$e);{local $@;$success=_clean_eval($make_sub,\%captures);$e=$@}unless ($success){die "Eval went very, very wrong:\n\n${make_sub}\n\n$e"}weaken($QUOTED{$$unquoted}=$quoted)}}$$unquoted}sub qsub ($) {goto&quote_sub}sub CLONE {%QUOTED=map {defined $_ ? ($_->[3]&& ${$_->[3]}? (${$_->[3]}=>$_): (),$_->[4]? ($_->[4]=>$_): (),): ()}values%QUOTED;weaken($_)for values%QUOTED}1;
SUB_QUOTE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use App::dategrep;

exit App::dategrep::run();

__END__

=pod

=for stopwords dategrep DATESPEC datespec syslog apache blocksize zcat bzcat rsyslog timestamped logrotate ARGV Domgoergen merchantability configfile !syslog

=for HTML <a href="https://travis-ci.org/mdom/dategrep"><img src="https://travis-ci.org/mdom/dategrep.svg?branch=master"></a>

=for HTML <a href='https://coveralls.io/r/mdom/dategrep?branch=master'><img src='https://coveralls.io/repos/mdom/dategrep/badge.png?branch=master' alt='Coverage Status' /></a> 

=head1 NAME

dategrep - print lines matching a date range

=head1 SYNOPSIS

  dategrep --start "12:00" --end "12:15" --format "%b %d %H:%M:%S" syslog
  dategrep --end "12:15" --format "%b %d %H:%M:%S" syslog
  dategrep --last-minutes 5 --format "%b %d %H:%M:%S" syslog
  dategrep --last-minutes 5 --format rsyslog syslog
  cat syslog | dategrep --end "12:15"

=head1 DESCRIPTION

dategrep searches the named input files for lines matching a date range
and prints them to stdout.

If dategrep works on a seekable file, it can do a binary search to find
the first and last line to print pretty efficiently. dategrep can also
read from stdin and compressed files, but it has to parse every single
line until the end of the range for those.

=head1 OPTIONS

=over 4

=item --start|--from DATESPEC

Print all lines from DATESPEC inclusively. Defaults to Jan 1, 1970 00:00:00 GMT.
See
L<VALID-DATE-FORMATS|https://metacpan.org/pod/distribution/Date-Manip/lib/Date/Manip/Date.pod#VALID-DATE-FORMATS>
for a list of possible formats for DATESPEC.

Additional it's possible to express offsets against dates by using the special
syntax I<$delta from $date>, for example

  --from "1 hour ago from -17:00" --to "-17:00"

would search entries from 16:17 to 17:17 if we had now 17:30.

=item --end|--to DATESPEC

Print all lines until DATESPEC exclusively. Default to the current time. See I<--start>
for a list of possible formats for DATESPEC.

=item --last-minutes MINUTES

Print all lines from MINUTES minutes ago until the beginning of the current
minute. So if we have 19:25:43 and MINUTES is five, dategrep will print all
lines from 19:20:00 to 19:24:59.

=item --format FORMAT

Defines a strftime-based FORMAT that is used to parse the input
lines for a date. The first date found on a line is used. The
list of possible escape sequences can be found under L<PRINTF
DIRECTIVES|https://metacpan.org/pod/distribution/Date-Manip/lib/Date/Manip/Date.pod#PRINTF-DIRECTIVES>.

This is a required parameter. Alternatively you can supply the format
via the environment variable I<DATEGREP_DEFAULT_FORMAT>.

Additionally, dategrep supports named formats:

=over 4

=item * rsyslog "%b %e %H:%M:%S"

=item * apache "%d/%b/%Y:%T %z"

=item * iso8601 "%O%Z"

=back

=item --multiline

Print all lines between the start and end line even if they are not timestamped.

=item --blocksize SIZE

SIZE of the intervals used in the binary search. Defaults to the native
blocksize of the file's filesystem or 8129.

=item --interleave

Print lines sorted by timestamp even if the timestamps in the input files
are overlapping.

=item --sort-files

Sort files in the order of the first line with a timestamp. For example:
If you have a common logrotate configuration, you probably have files
like syslog, syslog.1, syslog.2 etc. For dategrep to work we need those
files in reverse order: syslog.2, syslog.1, syslog. This options handles
that for you.

=item --configfile FILE

Reads configuration from FILE instead of I<~/.dategreprc>.

=item --help 

Shows a short help message

=item --man

Shows the complete man page in your pager.

=back

=head1 CONFIGURATION FILE

On startup dategrep reads a configuration file from I<$HOME/.dategreprc> or the
file specified by I<--configfile>. 

The file consists of sections and variables. A section begins with the name of
the section in square brackets and continues until the next section begins.
Section names are not case sensitive. Empty lines and lines with comments are
skipped. Comments are started with a hash character. dategrep recognizes
only one sections: Under I<formats> you can list additional named formats.

Example:

  [formats]
  time = %H:%M:%S

=head1 ENVIRONMENT

=over 4

=item DATEGREP_DEFAULT_FORMAT

Default for the I<--format> parameter. The syntax is described there.

=back

=head1 COMPRESSED FILES

dategrep has only minimal support for compressed files. If any file in
ARGV has an extension like I<.z>,I<.gz>,I<.bz2>,I<.bz>, dategrep will
call I<zcat> or I<bzcat> respectively and read from it like from stdin.

=head1 LIMITATION

dategrep expects the files to be sorted. If the timestamps are not
ascending, dategrep might be exiting before the last line in its date
range is printed.

Compressed files are just piped into dategrep via bzcat or zcat.

=head1 SEE ALSO

L<https://metacpan.org/pod/Date::Manip>

=head1 COPYRIGHT AND LICENSE

Copyright 2014 Mario Domgoergen C<< <mario@domgoergen.com> >>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
